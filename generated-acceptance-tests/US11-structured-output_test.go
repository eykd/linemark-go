// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US11-structured-output.txt

package acceptance_test

import (
	"encoding/json"
	"testing"
)

// All commands support structured output.
// Source: specs/US11-structured-output.txt:2
func Test_All_commands_support_structured_output(t *testing.T) {
	// GIVEN a populated outline.
	dir := initProject(t)
	addNode(t, dir, "Chapter One")
	addNode(t, dir, "Chapter Two")

	// WHEN the author runs list --json.
	listOut := runLmkSuccess(t, dir, "list", "--json")
	var listResult map[string]interface{}
	if err := json.Unmarshal([]byte(listOut), &listResult); err != nil {
		t.Fatalf("list --json output is not valid JSON: %v\noutput: %s", err, listOut)
	}

	// WHEN the author runs check --json.
	checkOut := runLmkSuccess(t, dir, "check", "--json")
	var checkResult map[string]interface{}
	if err := json.Unmarshal([]byte(checkOut), &checkResult); err != nil {
		t.Fatalf("check --json output is not valid JSON: %v\noutput: %s", err, checkOut)
	}

	// WHEN the author runs add --json.
	addOut := runLmkSuccess(t, dir, "add", "--json", "Chapter Three")
	var addResult map[string]interface{}
	if err := json.Unmarshal([]byte(addOut), &addResult); err != nil {
		t.Fatalf("add --json output is not valid JSON: %v\noutput: %s", err, addOut)
	}

	// THEN all outputs are valid parseable structured data.
	if listResult == nil || checkResult == nil || addResult == nil {
		t.Fatal("one or more JSON results parsed to nil")
	}
}

// Dry-run with structured output shows planned changes.
// Source: specs/US11-structured-output.txt:12
func Test_Dry_run_with_structured_output_shows_planned_changes(t *testing.T) {
	// GIVEN an outline with nodes.
	dir := initProject(t)
	addNodeJSON(t, dir, "Chapter One")
	addNodeJSON(t, dir, "Chapter Two")
	addNodeJSON(t, dir, "Chapter Three")
	// Delete middle to create gap for compact.
	runLmkSuccess(t, dir, "delete", "200", "--force")

	snap := snapshotFiles(t, dir)

	// WHEN the author requests a dry-run of compact with structured output.
	compactOut := runLmkSuccess(t, dir, "--dry-run", "compact", "--json")

	// THEN the planned changes are shown as structured data.
	var compactResult map[string]interface{}
	if err := json.Unmarshal([]byte(compactOut), &compactResult); err != nil {
		t.Fatalf("compact --json output is not valid JSON: %v", err)
	}
	if _, ok := compactResult["renames"]; !ok {
		t.Fatal("compact --json output missing 'renames'")
	}
	planned, _ := compactResult["planned"].(bool)
	if !planned {
		t.Fatal("expected planned: true for dry-run")
	}

	// THEN no files are modified.
	assertSnapshotUnchanged(t, dir, snap)
}

// Exit codes are consistent across commands.
// Source: specs/US11-structured-output.txt:23
func Test_Exit_codes_are_consistent_across_commands(t *testing.T) {
	// Scenario 1: Success - exit 0.
	dir := initProject(t)
	addNode(t, dir, "Chapter One")
	_, _, exitCode := runLmk(t, dir, "list")
	if exitCode != 0 {
		t.Fatalf("expected exit 0 for success, got %d", exitCode)
	}

	// Scenario 2: Error - exit 1 (outside project).
	noProjectDir := t.TempDir()
	_, _, exitCode = runLmk(t, noProjectDir, "list")
	if exitCode != 1 {
		t.Fatalf("expected exit 1 for error, got %d", exitCode)
	}

	// Scenario 3: Check with findings - exit 1.
	// Create duplicate SID files to trigger check failure.
	dupSID := "FAKESID12345"
	writeFile(t, dir, "900_"+dupSID+"_draft_dupe-a.md", "---\ntitle: Dupe A\n---\n")
	writeFile(t, dir, "900_"+dupSID+"_notes.md", "")
	writeFile(t, dir, "800_"+dupSID+"_draft_dupe-b.md", "---\ntitle: Dupe B\n---\n")
	writeFile(t, dir, "800_"+dupSID+"_notes.md", "")

	_, _, exitCode = runLmk(t, dir, "check")
	if exitCode == 0 {
		t.Fatal("expected non-zero exit for check with findings")
	}
}
