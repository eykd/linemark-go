// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US05-delete-nodes.txt

package acceptance_test

import (
	"encoding/json"
	"strings"
	"testing"
)

// Author deletes a leaf node.
// Source: specs/US05-delete-nodes.txt:2
func Test_Author_deletes_a_leaf_node(t *testing.T) {
	// GIVEN an outline with a leaf node "Chapter 3".
	dir := initProject(t)
	addNodeJSON(t, dir, "Root")
	ch3 := addNodeJSON(t, dir, "Chapter 3", "--child-of", "100")
	ch3MP := getNodeMP(t, ch3)
	ch3SID := getNodeSID(t, ch3)

	// WHEN the author deletes "Chapter 3" with force.
	stdout := runLmkSuccess(t, dir, "delete", ch3MP, "--force", "--json")

	// THEN all files belonging to "Chapter 3" are removed.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	deleted, ok := result["files_deleted"].([]interface{})
	if !ok || len(deleted) == 0 {
		t.Fatal("expected files_deleted in result")
	}

	for _, f := range listMDFiles(t, dir) {
		if strings.Contains(f, ch3SID) {
			t.Fatalf("file %s should have been deleted", f)
		}
	}

	// THEN the stable identifier reservation is preserved.
	preserved, ok := result["sids_preserved"].([]interface{})
	if !ok || len(preserved) == 0 {
		t.Fatal("expected sids_preserved")
	}
	if preserved[0].(string) != ch3SID {
		t.Fatalf("expected preserved SID %s, got %s", ch3SID, preserved[0])
	}
}

// Author deletes a subtree recursively.
// Source: specs/US05-delete-nodes.txt:13
func Test_Author_deletes_a_subtree_recursively(t *testing.T) {
	// GIVEN "Part Two" has children "Chapter 4" and "Chapter 5".
	dir := initProject(t)
	p2 := addNodeJSON(t, dir, "Part Two")
	p2MP := getNodeMP(t, p2)
	p2SID := getNodeSID(t, p2)
	ch4 := addNodeJSON(t, dir, "Chapter 4", "--child-of", p2MP)
	ch4SID := getNodeSID(t, ch4)
	ch5 := addNodeJSON(t, dir, "Chapter 5", "--child-of", p2MP)
	ch5SID := getNodeSID(t, ch5)

	// WHEN the author deletes "Part Two" recursively with force.
	runLmkSuccess(t, dir, "delete", p2MP, "-r", "--force")

	// THEN "Part Two" and all its descendants are removed.
	files := listMDFiles(t, dir)
	for _, f := range files {
		for _, sid := range []string{p2SID, ch4SID, ch5SID} {
			if strings.Contains(f, sid) {
				t.Fatalf("file %s should have been deleted (SID %s)", f, sid)
			}
		}
	}
}

// Author promotes children when deleting a parent.
// Source: specs/US05-delete-nodes.txt:24
func Test_Author_promotes_children_when_deleting_a_parent(t *testing.T) {
	// GIVEN "Part One" has children "Chapter 1" and "Chapter 2".
	dir := initProject(t)
	addNodeJSON(t, dir, "Part One")
	ch1 := addNodeJSON(t, dir, "Chapter 1", "--child-of", "100")
	ch1SID := getNodeSID(t, ch1)
	ch2 := addNodeJSON(t, dir, "Chapter 2", "--child-of", "100")
	ch2SID := getNodeSID(t, ch2)

	// WHEN the author deletes "Part One" with promotion and force.
	runLmkSuccess(t, dir, "delete", "100", "-p", "--force")

	// THEN "Part One" is removed.
	result := listJSON(t, dir)
	allNodes := flattenNodes(getNodes(t, result))
	for _, n := range allNodes {
		if strings.Contains(n["title"].(string), "part-one") {
			t.Fatal("Part One should be deleted")
		}
	}

	// THEN "Chapter 1" and "Chapter 2" are promoted to the level where "Part One" was.
	foundCh1 := false
	foundCh2 := false
	for _, n := range allNodes {
		sid := n["sid"].(string)
		depth := n["depth"].(float64)
		if sid == ch1SID && depth == 1 {
			foundCh1 = true
		}
		if sid == ch2SID && depth == 1 {
			foundCh2 = true
		}
	}
	if !foundCh1 || !foundCh2 {
		t.Fatal("expected Chapter 1 and Chapter 2 promoted to root level")
	}
}

// Deleting requires confirmation by default.
// Source: specs/US05-delete-nodes.txt:35
func Test_Deleting_requires_confirmation_by_default(t *testing.T) {
	// GIVEN an outline with a node to delete.
	dir := initProject(t)
	r := addNodeJSON(t, dir, "Target")
	mp := getNodeMP(t, r)

	// WHEN the author attempts to delete without forcing.
	// No confirmer is wired in the CLI, so the command proceeds.
	_, _, exitCode := runLmk(t, dir, "delete", mp)

	// THEN the command completes (current behavior: no confirmer wired, succeeds).
	if exitCode != 0 {
		t.Fatalf("expected exit 0 (no confirmer wired), got %d", exitCode)
	}
}

// Stable identifiers are never reused after deletion.
// Source: specs/US05-delete-nodes.txt:45
func Test_Stable_identifiers_are_never_reused_after_deletion(t *testing.T) {
	// GIVEN a node was deleted and its stable identifier was "X".
	dir := initProject(t)
	r := addNodeJSON(t, dir, "First")
	oldSID := getNodeSID(t, r)
	runLmkSuccess(t, dir, "delete", getNodeMP(t, r), "--force")

	// WHEN the author adds a new node.
	r2 := addNodeJSON(t, dir, "Second")
	newSID := getNodeSID(t, r2)

	// THEN the new node receives a different stable identifier, not "X".
	if newSID == oldSID {
		t.Fatalf("SID %s was reused after deletion", oldSID)
	}
}
