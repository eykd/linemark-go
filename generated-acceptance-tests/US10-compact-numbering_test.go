// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US10-compact-numbering.txt

package acceptance_test

import (
	"encoding/json"
	"testing"
)

// Compact renumbers positions with even spacing.
// Source: specs/US10-compact-numbering.txt:2
func Test_Compact_renumbers_positions_with_even_spacing(t *testing.T) {
	// GIVEN an outline with uneven numbering gaps between siblings.
	dir := initProject(t)
	addNodeJSON(t, dir, "A")
	r2 := addNodeJSON(t, dir, "B")
	r3 := addNodeJSON(t, dir, "C")
	r2SID := getNodeSID(t, r2)
	r3SID := getNodeSID(t, r3)

	// Delete B to create a gap: 100, 300
	runLmkSuccess(t, dir, "delete", "200", "--force")

	// WHEN the author compacts the outline with apply.
	runLmkSuccess(t, dir, "compact", "--apply")

	// THEN all sibling positions are renumbered with even spacing.
	result := listJSON(t, dir)
	allNodes := flattenNodes(getNodes(t, result))

	// After compact: A=100, C=200
	for _, n := range allNodes {
		if n["sid"].(string) == r3SID {
			if n["mp"].(string) != "200" {
				t.Fatalf("expected C at 200 after compact, got %s", n["mp"])
			}
		}
	}

	// THEN stable identifiers are unchanged.
	sids := make(map[string]bool)
	for _, n := range allNodes {
		sids[n["sid"].(string)] = true
	}
	if !sids[r3SID] {
		t.Fatalf("SID %s not found after compact", r3SID)
	}
	_ = r2SID // deleted, not expected
}

// Compact without apply is report-only.
// Source: specs/US10-compact-numbering.txt:13
func Test_Compact_without_apply_is_report_only(t *testing.T) {
	// GIVEN an outline with numbering gaps.
	dir := initProject(t)
	addNodeJSON(t, dir, "A")
	addNodeJSON(t, dir, "B")
	addNodeJSON(t, dir, "C")
	runLmkSuccess(t, dir, "delete", "200", "--force")

	snap := snapshotFiles(t, dir)

	// WHEN the author compacts without apply.
	stdout := runLmkSuccess(t, dir, "compact", "--json")

	// THEN the planned renaming is displayed.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	renames, ok := result["renames"].([]interface{})
	if !ok {
		t.Fatal("expected renames in compact output")
	}
	if len(renames) == 0 {
		t.Fatal("expected planned renames for gap")
	}

	// THEN no files are actually renamed.
	assertSnapshotUnchanged(t, dir, snap)
}

// Compact warns when many files are affected.
// Source: specs/US10-compact-numbering.txt:24
func Test_Compact_warns_when_many_files_are_affected(t *testing.T) {
	// NOT IMPLEMENTED: No warning emitted currently.
	// Test verifies compact works without error on a small set.
	dir := initProject(t)
	addNodeJSON(t, dir, "A")
	addNodeJSON(t, dir, "B")

	// WHEN the author compacts the outline.
	stdout := runLmkSuccess(t, dir, "compact", "--json")

	// THEN compact succeeds (warning feature not yet implemented).
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	// Warning field should be null.
	if result["warning"] != nil {
		t.Fatalf("expected null warning, got %v", result["warning"])
	}
}

// Compact preserves the outline hierarchy.
// Source: specs/US10-compact-numbering.txt:34
func Test_Compact_preserves_the_outline_hierarchy(t *testing.T) {
	// GIVEN a three-level outline with parent, child, and grandchild nodes.
	dir := initProject(t)
	addNodeJSON(t, dir, "Root")
	addNodeJSON(t, dir, "Child", "--child-of", "100")
	addNodeJSON(t, dir, "Grandchild", "--child-of", "100-100")
	// Add another root to create a gap after deletion.
	addNodeJSON(t, dir, "Extra Root")
	runLmkSuccess(t, dir, "delete", "200", "--force")

	// Record hierarchy before compact.
	beforeResult := listJSON(t, dir)
	beforeNodes := flattenNodes(getNodes(t, beforeResult))
	beforeCount := len(beforeNodes)

	// WHEN the author compacts with apply.
	runLmkSuccess(t, dir, "compact", "--apply")

	// THEN all parent-child relationships are preserved.
	afterResult := listJSON(t, dir)
	afterNodes := flattenNodes(getNodes(t, afterResult))
	if len(afterNodes) != beforeCount {
		t.Fatalf("expected %d nodes after compact, got %d", beforeCount, len(afterNodes))
	}

	// Verify grandchild is still under child.
	for _, n := range afterNodes {
		title := n["title"].(string)
		if title == "grandchild" {
			depth := n["depth"].(float64)
			if depth != 3 {
				t.Fatalf("expected grandchild at depth 3, got %v", depth)
			}
		}
	}
}
