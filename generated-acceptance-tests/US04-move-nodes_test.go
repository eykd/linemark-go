// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US04-move-nodes.txt

package acceptance_test

import (
	"encoding/json"
	"strings"
	"testing"
)

// Author moves a node to a new parent.
// Source: specs/US04-move-nodes.txt:2
func Test_Author_moves_a_node_to_a_new_parent(t *testing.T) {
	// GIVEN an outline with "Part One" containing "Chapter 1" and a separate "Part Two".
	dir := initProject(t)
	addNodeJSON(t, dir, "Part One")
	ch1 := addNodeJSON(t, dir, "Chapter 1", "--child-of", "100")
	ch1MP := getNodeMP(t, ch1)
	addNodeJSON(t, dir, "Part Two")

	// WHEN the author moves "Chapter 1" to be a child of "Part Two".
	runLmkSuccess(t, dir, "move", ch1MP, "--to", "200")

	// THEN "Chapter 1" appears under "Part Two".
	result := listJSON(t, dir)
	nodes := getNodes(t, result)
	allNodes := flattenNodes(nodes)

	foundUnderP2 := false
	for _, n := range allNodes {
		mp := n["mp"].(string)
		title := n["title"].(string)
		if strings.Contains(title, "chapter-1") && strings.HasPrefix(mp, "200-") {
			foundUnderP2 = true
		}
	}
	if !foundUnderP2 {
		t.Fatal("expected Chapter 1 under Part Two after move")
	}

	// THEN "Chapter 1" no longer appears under "Part One".
	for _, n := range allNodes {
		mp := n["mp"].(string)
		title := n["title"].(string)
		if strings.Contains(title, "chapter-1") && strings.HasPrefix(mp, "100-") {
			t.Fatal("Chapter 1 should no longer be under Part One")
		}
	}
}

// Moving a node preserves its descendants.
// Source: specs/US04-move-nodes.txt:13
func Test_Moving_a_node_preserves_its_descendants(t *testing.T) {
	// GIVEN "Chapter 1" has children "Scene 1" and "Scene 2".
	dir := initProject(t)
	addNodeJSON(t, dir, "Part One")
	ch1 := addNodeJSON(t, dir, "Chapter 1", "--child-of", "100")
	ch1MP := getNodeMP(t, ch1)
	addNodeJSON(t, dir, "Scene 1", "--child-of", ch1MP)
	addNodeJSON(t, dir, "Scene 2", "--child-of", ch1MP)
	addNodeJSON(t, dir, "Part Two")

	// WHEN the author moves "Chapter 1" to a new parent.
	runLmkSuccess(t, dir, "move", ch1MP, "--to", "200")

	// THEN "Scene 1" and "Scene 2" remain as children of "Chapter 1".
	result := listJSON(t, dir)
	allNodes := flattenNodes(getNodes(t, result))

	sceneCount := 0
	for _, n := range allNodes {
		title := n["title"].(string)
		if strings.Contains(title, "scene-") {
			sceneCount++
		}
	}
	if sceneCount != 2 {
		t.Fatalf("expected 2 scenes preserved, found %d", sceneCount)
	}
}

// Moving a node preserves stable identifiers.
// Source: specs/US04-move-nodes.txt:23
func Test_Moving_a_node_preserves_stable_identifiers(t *testing.T) {
	// GIVEN a node with a known stable identifier.
	dir := initProject(t)
	addNodeJSON(t, dir, "Part One")
	ch1 := addNodeJSON(t, dir, "Chapter 1", "--child-of", "100")
	ch1MP := getNodeMP(t, ch1)
	ch1SID := getNodeSID(t, ch1)
	addNodeJSON(t, dir, "Part Two")

	// WHEN the author moves the node to a new position.
	runLmkSuccess(t, dir, "move", ch1MP, "--to", "200")

	// THEN the node's stable identifier is unchanged.
	result := listJSON(t, dir)
	allNodes := flattenNodes(getNodes(t, result))
	found := false
	for _, n := range allNodes {
		if n["sid"].(string) == ch1SID {
			found = true
			break
		}
	}
	if !found {
		t.Fatalf("SID %s not found after move", ch1SID)
	}
}

// Author previews a move without executing it.
// Source: specs/US04-move-nodes.txt:33
func Test_Author_previews_a_move_without_executing_it(t *testing.T) {
	// GIVEN an outline with nodes to move.
	dir := initProject(t)
	addNodeJSON(t, dir, "Part One")
	ch1 := addNodeJSON(t, dir, "Chapter 1", "--child-of", "100")
	ch1MP := getNodeMP(t, ch1)
	addNodeJSON(t, dir, "Part Two")

	snap := snapshotFiles(t, dir)

	// WHEN the author requests a dry-run move.
	stdout := runLmkSuccess(t, dir, "--dry-run", "move", ch1MP, "--to", "200", "--json")

	// THEN the planned file changes are displayed.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	renames, ok := result["renames"].([]interface{})
	if !ok || len(renames) == 0 {
		t.Fatal("expected renames in dry-run output")
	}
	planned, _ := result["planned"].(bool)
	if !planned {
		t.Fatal("expected planned: true in dry-run output")
	}

	// THEN no files are actually modified.
	assertSnapshotUnchanged(t, dir, snap)
}

// Moving a node into its own subtree is rejected.
// Source: specs/US04-move-nodes.txt:44
func Test_Moving_a_node_into_its_own_subtree_is_rejected(t *testing.T) {
	// GIVEN a node "Part One" with descendant "Chapter 1".
	dir := initProject(t)
	addNodeJSON(t, dir, "Part One")
	addNodeJSON(t, dir, "Chapter 1", "--child-of", "100")

	snap := snapshotFiles(t, dir)

	// WHEN the author attempts to move "Part One" to be a child of "Chapter 1".
	_, stderr, exitCode := runLmk(t, dir, "move", "100", "--to", "100-100")

	// THEN the operation is rejected with an error.
	if exitCode == 0 {
		t.Fatal("expected non-zero exit code for cycle")
	}
	if !strings.Contains(stderr, "cycle") {
		t.Fatalf("expected cycle error, got: %s", stderr)
	}

	// THEN no files are modified.
	assertSnapshotUnchanged(t, dir, snap)
}
