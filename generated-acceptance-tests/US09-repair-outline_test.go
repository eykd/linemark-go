// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US09-repair-outline.txt

package acceptance_test

import (
	"encoding/json"
	"path/filepath"
	"testing"
)

// Doctor fixes slug drift when applied.
// Source: specs/US09-repair-outline.txt:2
func Test_Doctor_fixes_slug_drift_when_applied(t *testing.T) {
	// GIVEN a node whose filename slug does not match its canonical title.
	dir := initProject(t)
	r := addNodeJSON(t, dir, "Correct Title")
	mp := getNodeMP(t, r)
	sid := getNodeSID(t, r)

	oldFile := mp + "_" + sid + "_draft_correct-title.md"
	wrongFile := mp + "_" + sid + "_draft_wrong-slug.md"
	content := readFile(t, dir, oldFile)
	writeFile(t, dir, wrongFile, content)
	removeFile(t, dir, oldFile)

	// WHEN the author runs doctor with apply.
	stdout := runLmkSuccess(t, dir, "doctor", "--apply", "--json")

	// THEN the files are renamed to match the canonical title.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	repairs, ok := result["repairs"].([]interface{})
	if !ok || len(repairs) == 0 {
		t.Fatal("expected repairs in doctor output")
	}

	if !fileExists(dir, oldFile) {
		t.Fatalf("expected %s to be restored by doctor", oldFile)
	}
	if fileExists(dir, wrongFile) {
		t.Fatalf("expected %s to be renamed away", wrongFile)
	}
}

// Doctor creates missing notes files when applied.
// Source: specs/US09-repair-outline.txt:12
func Test_Doctor_creates_missing_notes_files_when_applied(t *testing.T) {
	// GIVEN a node that is missing its notes document.
	dir := initProject(t)
	fakeSID := "FAKESID12345"
	writeFile(t, dir, "100_"+fakeSID+"_draft_test.md", "---\ntitle: Test\n---\n")

	// WHEN the author runs doctor with apply.
	runLmkSuccess(t, dir, "doctor", "--apply")

	// THEN an empty notes file is created for the node.
	notesFile := "100_" + fakeSID + "_notes.md"
	if !fileExists(dir, notesFile) {
		t.Fatalf("expected notes file %s to be created", notesFile)
	}
}

// Doctor creates missing identifier reservations when applied.
// Source: specs/US09-repair-outline.txt:22
func Test_Doctor_creates_missing_identifier_reservations_when_applied(t *testing.T) {
	// GIVEN a node whose stable identifier has no reservation marker.
	dir := initProject(t)
	fakeSID := "FAKESID12345"
	writeFile(t, dir, "100_"+fakeSID+"_draft_test-node.md", "---\ntitle: Test Node\n---\n")
	writeFile(t, dir, "100_"+fakeSID+"_notes.md", "")

	// Verify the reservation marker does NOT exist yet.
	markerPath := filepath.Join(".linemark", "ids", fakeSID)
	if fileExists(dir, markerPath) {
		t.Fatal("precondition: reservation marker should not exist yet")
	}

	// WHEN the author runs doctor with apply.
	stdout := runLmkSuccess(t, dir, "doctor", "--apply", "--json")

	// THEN the missing reservation marker is created.
	if !fileExists(dir, markerPath) {
		t.Fatalf("expected reservation marker at %s to be created by doctor", markerPath)
	}

	// AND the repair is reported in the output.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	repairs, ok := result["repairs"].([]interface{})
	if !ok || len(repairs) == 0 {
		t.Fatal("expected repairs for missing reservation marker")
	}
	foundReservationRepair := false
	for _, r := range repairs {
		repair, ok := r.(map[string]interface{})
		if !ok {
			continue
		}
		if repair["type"] == "missing_reservation" {
			foundReservationRepair = true
			break
		}
	}
	if !foundReservationRepair {
		t.Fatalf("expected missing_reservation repair in output, got repairs: %v", repairs)
	}
}

// Doctor reports but never auto-repairs duplicate identifiers.
// Source: specs/US09-repair-outline.txt:32
func Test_Doctor_reports_but_never_auto_repairs_duplicate_identifiers(t *testing.T) {
	// GIVEN two nodes share the same stable identifier.
	dir := initProject(t)
	dupSID := "FAKESID12345"
	writeFile(t, dir, "100_"+dupSID+"_draft_alpha.md", "---\ntitle: Alpha\n---\n")
	writeFile(t, dir, "100_"+dupSID+"_notes.md", "")
	writeFile(t, dir, "200_"+dupSID+"_draft_beta.md", "---\ntitle: Beta\n---\n")
	writeFile(t, dir, "200_"+dupSID+"_notes.md", "")

	// WHEN the author runs doctor with apply.
	stdout, _, exitCode := runLmk(t, dir, "doctor", "--apply", "--json")

	// THEN the duplicate identifier is reported.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v\noutput: %s", err, stdout)
	}
	unrepaired, ok := result["unrepaired"].([]interface{})
	if !ok || len(unrepaired) == 0 {
		t.Fatal("expected unrepaired findings for duplicate SIDs")
	}

	// THEN no automatic repair is attempted for the duplicate.
	if exitCode == 0 {
		t.Fatal("expected non-zero exit code for unrepaired findings")
	}
}

// Doctor without apply behaves as report-only.
// Source: specs/US09-repair-outline.txt:43
func Test_Doctor_without_apply_behaves_as_report_only(t *testing.T) {
	// GIVEN an outline with repairable findings.
	dir := initProject(t)
	writeFile(t, dir, "100_FAKESID12345_draft_test.md", "---\ntitle: Test\n---\n")

	snap := snapshotFiles(t, dir)

	// WHEN the author runs doctor without apply.
	stdout, _, _ := runLmk(t, dir, "doctor", "--json")

	// THEN findings are reported.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	findings, ok := result["findings"].([]interface{})
	if !ok || len(findings) == 0 {
		t.Fatal("expected findings reported")
	}

	// THEN no files are modified.
	assertSnapshotUnchanged(t, dir, snap)
}

// Doctor is idempotent.
// Source: specs/US09-repair-outline.txt:54
func Test_Doctor_is_idempotent(t *testing.T) {
	// GIVEN an outline with repairable findings.
	dir := initProject(t)
	writeFile(t, dir, "100_FAKESID12345_draft_test.md", "---\ntitle: Test\n---\n")

	// WHEN the author runs doctor with apply twice in succession.
	runLmkSuccess(t, dir, "doctor", "--apply")
	stdout := runLmkSuccess(t, dir, "doctor", "--apply", "--json")

	// THEN the second run reports no findings and makes no changes.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	repairs, _ := result["repairs"].([]interface{})
	if len(repairs) != 0 {
		t.Fatalf("expected 0 repairs on second run, got %d", len(repairs))
	}
}
