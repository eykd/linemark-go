// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US02-build-hierarchical-outline.txt

package acceptance_test

import (
	"strings"
	"testing"
)

// Author adds a child node under an existing node.
// Source: specs/US02-build-hierarchical-outline.txt:2
func Test_Author_adds_a_child_node_under_an_existing_node(t *testing.T) {
	// GIVEN an outline with a single root node titled "My Novel".
	dir := initProject(t)
	rootResult := addNodeJSON(t, dir, "My Novel")
	rootMP := getNodeMP(t, rootResult)

	// WHEN the author adds a child node titled "Chapter 1" under "My Novel".
	childResult := addNodeJSON(t, dir, "Chapter 1", "--child-of", rootMP)
	childMP := getNodeMP(t, childResult)

	// THEN the outline contains 2 nodes.
	listResult := listJSON(t, dir)
	nodes := getNodes(t, listResult)
	allNodes := flattenNodes(nodes)
	if len(allNodes) != 2 {
		t.Fatalf("expected 2 nodes, got %d", len(allNodes))
	}

	// THEN "Chapter 1" appears as a child of "My Novel".
	rootNode := nodes[0].(map[string]interface{})
	children, ok := rootNode["children"].([]interface{})
	if !ok || len(children) == 0 {
		t.Fatal("root node has no children; expected Chapter 1 as child")
	}
	child := children[0].(map[string]interface{})
	childTitle, _ := child["title"].(string)
	// Title in list JSON is the slug (lowercase-hyphenated).
	if childTitle != "chapter-1" {
		t.Fatalf("expected child title slug 'chapter-1', got %q", childTitle)
	}

	// THEN the child's position in the filename reflects the parent-child relationship.
	if !strings.HasPrefix(childMP, rootMP+"-") {
		t.Fatalf("child MP %q does not start with parent MP %q prefix", childMP, rootMP)
	}
}

// Author adds a sibling node after an existing node.
// Source: specs/US02-build-hierarchical-outline.txt:14
func Test_Author_adds_a_sibling_node_after_an_existing_node(t *testing.T) {
	// GIVEN an outline with a root node "Part One" that has a child "Chapter 1".
	dir := initProject(t)
	rootResult := addNodeJSON(t, dir, "Part One")
	rootMP := getNodeMP(t, rootResult)
	ch1Result := addNodeJSON(t, dir, "Chapter 1", "--child-of", rootMP)
	ch1MP := getNodeMP(t, ch1Result)

	// WHEN the author adds a sibling of "Chapter 1" titled "Chapter 2".
	ch2Result := addNodeJSON(t, dir, "Chapter 2", "--sibling-of", ch1MP)
	ch2MP := getNodeMP(t, ch2Result)

	// THEN the outline contains 3 nodes.
	listResult := listJSON(t, dir)
	nodes := getNodes(t, listResult)
	allNodes := flattenNodes(nodes)
	if len(allNodes) != 3 {
		t.Fatalf("expected 3 nodes, got %d", len(allNodes))
	}

	// THEN "Chapter 2" appears as a sibling immediately after "Chapter 1".
	rootNode := nodes[0].(map[string]interface{})
	children, ok := rootNode["children"].([]interface{})
	if !ok || len(children) < 2 {
		t.Fatalf("expected at least 2 children under root, got %d", len(children))
	}
	firstChild := children[0].(map[string]interface{})
	secondChild := children[1].(map[string]interface{})
	if firstChild["title"].(string) != "chapter-1" {
		t.Fatalf("expected first child slug 'chapter-1', got %q", firstChild["title"])
	}
	if secondChild["title"].(string) != "chapter-2" {
		t.Fatalf("expected second child slug 'chapter-2', got %q", secondChild["title"])
	}
	if ch2MP <= ch1MP {
		t.Fatalf("Chapter 2 MP %q should be greater than Chapter 1 MP %q", ch2MP, ch1MP)
	}
}

// Author inserts a node between two siblings.
// Source: specs/US02-build-hierarchical-outline.txt:25
func Test_Author_inserts_a_node_between_two_siblings(t *testing.T) {
	// GIVEN an outline with "Chapter 1" and "Chapter 3" as siblings.
	dir := initProject(t)
	rootResult := addNodeJSON(t, dir, "My Book")
	rootMP := getNodeMP(t, rootResult)
	ch1Result := addNodeJSON(t, dir, "Chapter 1", "--child-of", rootMP)
	ch1MP := getNodeMP(t, ch1Result)
	ch3Result := addNodeJSON(t, dir, "Chapter 3", "--child-of", rootMP)
	ch3MP := getNodeMP(t, ch3Result)

	// WHEN the author adds a node titled "Chapter 2" after "Chapter 1".
	ch2Result := addNodeJSON(t, dir, "Chapter 2", "--after", ch1MP)
	ch2MP := getNodeMP(t, ch2Result)

	// THEN "Chapter 2" sorts between "Chapter 1" and "Chapter 3" in the outline.
	listResult := listJSON(t, dir)
	nodes := getNodes(t, listResult)
	rootNode := nodes[0].(map[string]interface{})
	children, ok := rootNode["children"].([]interface{})
	if !ok || len(children) != 3 {
		t.Fatalf("expected 3 children under root, got %d", len(children))
	}

	titles := make([]string, len(children))
	for i, c := range children {
		node := c.(map[string]interface{})
		titles[i] = node["title"].(string)
	}
	if titles[0] != "chapter-1" || titles[1] != "chapter-2" || titles[2] != "chapter-3" {
		t.Fatalf("expected order [chapter-1, chapter-2, chapter-3], got %v", titles)
	}
	if ch2MP <= ch1MP || ch2MP >= ch3MP {
		t.Fatalf("Chapter 2 MP %q should be between %q and %q", ch2MP, ch1MP, ch3MP)
	}
}

// Author places a node before a specific sibling.
// Source: specs/US02-build-hierarchical-outline.txt:35
func Test_Author_places_a_node_before_a_specific_sibling(t *testing.T) {
	// GIVEN an outline with "Chapter 2" and "Chapter 3" as siblings.
	dir := initProject(t)
	rootResult := addNodeJSON(t, dir, "My Book")
	rootMP := getNodeMP(t, rootResult)
	ch2Result := addNodeJSON(t, dir, "Chapter 2", "--child-of", rootMP)
	ch2MP := getNodeMP(t, ch2Result)
	addNodeJSON(t, dir, "Chapter 3", "--child-of", rootMP)

	// WHEN the author adds a node titled "Chapter 1" before "Chapter 2".
	ch1Result := addNodeJSON(t, dir, "Chapter 1", "--before", ch2MP)
	ch1MP := getNodeMP(t, ch1Result)

	// THEN "Chapter 1" appears before "Chapter 2" in the outline.
	listResult := listJSON(t, dir)
	nodes := getNodes(t, listResult)
	rootNode := nodes[0].(map[string]interface{})
	children, ok := rootNode["children"].([]interface{})
	if !ok || len(children) != 3 {
		t.Fatalf("expected 3 children under root, got %d", len(children))
	}

	ch1Idx := -1
	ch2Idx := -1
	for i, c := range children {
		title := c.(map[string]interface{})["title"].(string)
		if title == "chapter-1" {
			ch1Idx = i
		}
		if title == "chapter-2" {
			ch2Idx = i
		}
	}
	if ch1Idx == -1 || ch2Idx == -1 {
		t.Fatal("chapter-1 or chapter-2 not found in children")
	}
	if ch1Idx >= ch2Idx {
		t.Fatalf("chapter-1 (idx %d) should appear before chapter-2 (idx %d)", ch1Idx, ch2Idx)
	}
	if ch1MP >= ch2MP {
		t.Fatalf("Chapter 1 MP %q should be less than Chapter 2 MP %q", ch1MP, ch2MP)
	}
}

// New children default to last position.
// Source: specs/US02-build-hierarchical-outline.txt:45
func Test_New_children_default_to_last_position(t *testing.T) {
	// GIVEN an outline with a root node that has children "Scene 1" and "Scene 2".
	dir := initProject(t)
	rootResult := addNodeJSON(t, dir, "Act One")
	rootMP := getNodeMP(t, rootResult)
	addNodeJSON(t, dir, "Scene 1", "--child-of", rootMP)
	sc2Result := addNodeJSON(t, dir, "Scene 2", "--child-of", rootMP)
	sc2MP := getNodeMP(t, sc2Result)

	// WHEN the author adds a child titled "Scene 3" under the root node.
	sc3Result := addNodeJSON(t, dir, "Scene 3", "--child-of", rootMP)
	sc3MP := getNodeMP(t, sc3Result)

	// THEN "Scene 3" appears after "Scene 2" in the outline.
	listResult := listJSON(t, dir)
	nodes := getNodes(t, listResult)
	rootNode := nodes[0].(map[string]interface{})
	children, ok := rootNode["children"].([]interface{})
	if !ok || len(children) != 3 {
		t.Fatalf("expected 3 children under root, got %d", len(children))
	}

	lastChild := children[len(children)-1].(map[string]interface{})
	if lastChild["title"].(string) != "scene-3" {
		t.Fatalf("expected last child slug 'scene-3', got %q", lastChild["title"])
	}
	if sc3MP <= sc2MP {
		t.Fatalf("Scene 3 MP %q should be greater than Scene 2 MP %q", sc3MP, sc2MP)
	}
}
