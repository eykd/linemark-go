// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US03-view-outline-as-tree.txt

package acceptance_test

import (
	"encoding/json"
	"strings"
	"testing"
)

// Author views the outline as an indented tree.
// Source: specs/US03-view-outline-as-tree.txt:2
func Test_Author_views_the_outline_as_an_indented_tree(t *testing.T) {
	// GIVEN an outline with "Part One" containing "Chapter 1" and "Chapter 2".
	dir := initProject(t)
	addNodeJSON(t, dir, "Part One")
	addNodeJSON(t, dir, "Chapter 1", "--child-of", "100")
	addNodeJSON(t, dir, "Chapter 2", "--child-of", "100")

	// WHEN the author lists the outline.
	stdout := runLmkSuccess(t, dir, "list")

	// THEN a human-readable indented tree is displayed.
	if !strings.Contains(stdout, "├── ") || !strings.Contains(stdout, "└── ") {
		t.Fatalf("expected box-drawing characters in tree output, got:\n%s", stdout)
	}

	// THEN each node shows its title and stable identifier.
	lines := strings.Split(strings.TrimSpace(stdout), "\n")
	if len(lines) < 3 {
		t.Fatalf("expected at least 3 lines, got %d:\n%s", len(lines), stdout)
	}
	if !strings.Contains(lines[0], "(") || !strings.Contains(lines[0], ")") {
		t.Fatalf("expected root line with (SID), got: %s", lines[0])
	}

	// THEN "Chapter 1" and "Chapter 2" are indented under "Part One".
	if !strings.Contains(stdout, "chapter-1") {
		t.Fatalf("expected chapter-1 in output:\n%s", stdout)
	}
	if !strings.Contains(stdout, "chapter-2") {
		t.Fatalf("expected chapter-2 in output:\n%s", stdout)
	}
}

// Author limits tree display depth.
// Source: specs/US03-view-outline-as-tree.txt:14
func Test_Author_limits_tree_display_depth(t *testing.T) {
	// GIVEN an outline with three levels: a part, a chapter, and a scene.
	dir := initProject(t)
	addNodeJSON(t, dir, "Part")
	addNodeJSON(t, dir, "Chapter", "--child-of", "100")
	addNodeJSON(t, dir, "Scene", "--child-of", "100-100")

	// WHEN the author lists the outline limited to depth 2.
	stdout := runLmkSuccess(t, dir, "list", "--depth", "2")

	// THEN the part and chapter are displayed.
	if !strings.Contains(stdout, "part") {
		t.Fatalf("expected part in output:\n%s", stdout)
	}
	if !strings.Contains(stdout, "chapter") {
		t.Fatalf("expected chapter in output:\n%s", stdout)
	}

	// THEN the scene is not displayed.
	if strings.Contains(stdout, "scene") {
		t.Fatalf("scene should not appear at depth 2:\n%s", stdout)
	}
}

// Author filters nodes by document type.
// Source: specs/US03-view-outline-as-tree.txt:25
func Test_Author_filters_nodes_by_document_type(t *testing.T) {
	// GIVEN an outline where some nodes have a "characters" document and others do not.
	dir := initProject(t)
	r1 := addNodeJSON(t, dir, "Node With Characters")
	mp1 := getNodeMP(t, r1)
	addNodeJSON(t, dir, "Node Without Characters")
	runLmkSuccess(t, dir, "types", "add", "characters", mp1)

	// WHEN the author lists nodes filtered to the "characters" type.
	stdout := runLmkSuccess(t, dir, "list", "--type", "characters")

	// THEN only nodes with a "characters" document are displayed.
	if !strings.Contains(stdout, "node-with-characters") {
		t.Fatalf("expected node-with-characters in filtered output:\n%s", stdout)
	}
	if strings.Contains(stdout, "node-without-characters") {
		t.Fatalf("unexpected node-without-characters in filtered output:\n%s", stdout)
	}
}

// Author requests structured output.
// Source: specs/US03-view-outline-as-tree.txt:35
func Test_Author_requests_structured_output(t *testing.T) {
	// GIVEN a populated outline with parent and child nodes.
	dir := initProject(t)
	addNodeJSON(t, dir, "Parent")
	addNodeJSON(t, dir, "Child", "--child-of", "100")

	// WHEN the author lists the outline requesting structured output.
	stdout := runLmkSuccess(t, dir, "list", "--json")

	// THEN the output is valid structured data with nested children.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v\noutput: %s", err, stdout)
	}

	nodes := getNodes(t, result)
	if len(nodes) < 1 {
		t.Fatal("expected at least 1 root node")
	}

	root := nodes[0].(map[string]interface{})

	// THEN each node includes its position, stable identifier, title, depth, and document types.
	for _, field := range []string{"mp", "sid", "title", "depth", "types", "children"} {
		if _, ok := root[field]; !ok {
			t.Fatalf("missing field %q in node", field)
		}
	}

	children, ok := root["children"].([]interface{})
	if !ok || len(children) == 0 {
		t.Fatal("expected children array with at least 1 child")
	}
}
