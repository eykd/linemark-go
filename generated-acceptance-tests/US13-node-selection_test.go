// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US13-node-selection.txt

package acceptance_test

import (
	"encoding/json"
	"strings"
	"testing"
)

// Author selects a node by its position.
// Source: specs/US13-node-selection.txt:2
func Test_Author_selects_a_node_by_its_position(t *testing.T) {
	// GIVEN an outline with a node at a known position.
	dir := initProject(t)
	r := addNodeJSON(t, dir, "Root")
	addNodeJSON(t, dir, "Child", "--child-of", getNodeMP(t, r))
	childMP := "100-100"

	// WHEN the author references the node by its position.
	stdout := runLmkSuccess(t, dir, "types", "list", childMP)

	// THEN the node at that position is selected.
	if !strings.Contains(stdout, "draft") {
		t.Fatalf("expected types output for node at %s, got: %s", childMP, stdout)
	}
}

// Author selects a node by its stable identifier.
// Source: specs/US13-node-selection.txt:12
func Test_Author_selects_a_node_by_its_stable_identifier(t *testing.T) {
	// GIVEN an outline with a node having a known stable identifier.
	dir := initProject(t)
	r := addNodeJSON(t, dir, "Target Node")
	sid := getNodeSID(t, r)

	// WHEN the author references the node by its stable identifier.
	// Using delete --dry-run since it supports SID selectors.
	stdout := runLmkSuccess(t, dir, "--dry-run", "delete", sid, "--force", "--json")

	// THEN the correct node is selected.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	preserved, ok := result["sids_preserved"].([]interface{})
	if !ok || len(preserved) == 0 {
		t.Fatal("expected sids_preserved in delete result")
	}
	if preserved[0].(string) != sid {
		t.Fatalf("expected SID %s in result, got %s", sid, preserved[0])
	}
}

// Ambiguous input defaults to position.
// Source: specs/US13-node-selection.txt:22
func Test_Ambiguous_input_defaults_to_position(t *testing.T) {
	// GIVEN an input that could match either a position or a stable identifier.
	dir := initProject(t)
	addNodeJSON(t, dir, "Test Node")

	// WHEN the input is resolved without an explicit prefix.
	// Bare "100" matches MP pattern and is resolved as position.
	stdout := runLmkSuccess(t, dir, "types", "list", "100")

	// THEN it is interpreted as a position.
	if !strings.Contains(stdout, "draft") {
		t.Fatalf("expected types output for position 100, got: %s", stdout)
	}
}

// Author uses explicit prefix for position.
// Source: specs/US13-node-selection.txt:32
func Test_Author_uses_explicit_prefix_for_position(t *testing.T) {
	// GIVEN an outline with a node.
	dir := initProject(t)
	r := addNodeJSON(t, dir, "Test Node")
	sid := getNodeSID(t, r)

	// WHEN the author references a node with a position prefix.
	// Using delete --dry-run since it supports explicit mp: prefix.
	stdout := runLmkSuccess(t, dir, "--dry-run", "delete", "mp:100", "--force", "--json")

	// THEN the node is looked up by position regardless of other patterns.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	preserved, ok := result["sids_preserved"].([]interface{})
	if !ok || len(preserved) == 0 {
		t.Fatal("expected sids_preserved in delete result")
	}
	if preserved[0].(string) != sid {
		t.Fatalf("expected SID %s, got %s", sid, preserved[0])
	}
}

// Author uses explicit prefix for stable identifier.
// Source: specs/US13-node-selection.txt:42
func Test_Author_uses_explicit_prefix_for_stable_identifier(t *testing.T) {
	// GIVEN an outline with a node.
	dir := initProject(t)
	r := addNodeJSON(t, dir, "Test Node")
	sid := getNodeSID(t, r)

	// WHEN the author references a node with an identifier prefix.
	// Using delete --dry-run since it supports SID selectors.
	stdout := runLmkSuccess(t, dir, "--dry-run", "delete", "sid:"+sid, "--force", "--json")

	// THEN the node is looked up by stable identifier regardless of other patterns.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v", err)
	}
	preserved, ok := result["sids_preserved"].([]interface{})
	if !ok || len(preserved) == 0 {
		t.Fatal("expected sids_preserved in delete result")
	}
	if preserved[0].(string) != sid {
		t.Fatalf("expected SID %s, got %s", sid, preserved[0])
	}
}
