// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US01-initialize-new-outline.txt

package acceptance_test

import (
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

// Author creates the first node in a new outline.
// Source: specs/US01-initialize-new-outline.txt:2
func Test_Author_creates_the_first_node_in_a_new_outline(t *testing.T) {
	// GIVEN an empty content directory.
	// WHEN the author adds a node titled "My Novel".
	// THEN two files are created in the content directory.
	// THEN one file is a draft containing the title "My Novel".
	// THEN the other file is an empty notes document.
	// THEN the node is assigned a unique stable identifier.
	// THEN the stable identifier is permanently reserved.
	// THEN the filenames contain the hierarchy position, stable identifier, document type, and a slugified title.

	// GIVEN an empty content directory.
	dir := initProject(t)

	// WHEN the author adds a node titled "My Novel".
	result := addNodeJSON(t, dir, "My Novel")
	mp := getNodeMP(t, result)
	sid := getNodeSID(t, result)

	// THEN two files are created in the content directory.
	mdFiles := listMDFiles(t, dir)
	if len(mdFiles) != 2 {
		t.Fatalf("expected 2 .md files, got %d: %v", len(mdFiles), mdFiles)
	}

	// THEN one file is a draft containing the title "My Novel".
	draftFile := ""
	notesFile := ""
	for _, f := range mdFiles {
		if strings.Contains(f, "_draft_") {
			draftFile = f
		}
		if strings.Contains(f, "_notes") {
			notesFile = f
		}
	}
	if draftFile == "" {
		t.Fatal("no draft file found among:", mdFiles)
	}
	draftContent := readFile(t, dir, draftFile)
	if !strings.Contains(draftContent, "title: My Novel") {
		t.Fatalf("draft file does not contain title 'My Novel', content:\n%s", draftContent)
	}

	// THEN the other file is an empty notes document.
	if notesFile == "" {
		t.Fatal("no notes file found among:", mdFiles)
	}
	notesContent := readFile(t, dir, notesFile)
	if len(notesContent) != 0 {
		t.Fatalf("expected notes file to be empty, got %d bytes: %q", len(notesContent), notesContent)
	}

	// THEN the node is assigned a unique stable identifier.
	sidPattern := regexp.MustCompile(`^[A-Za-z0-9]{8,12}$`)
	if !sidPattern.MatchString(sid) {
		t.Fatalf("SID %q does not match expected pattern [A-Za-z0-9]{8,12}", sid)
	}

	// THEN the stable identifier is permanently reserved.
	// Adding a second node should produce a different SID.
	result2 := addNodeJSON(t, dir, "Part Two")
	sid2 := getNodeSID(t, result2)
	if sid == sid2 {
		t.Fatalf("second node got same SID %q as first node; SID should be permanently reserved", sid)
	}

	// THEN the filenames contain the hierarchy position, stable identifier, document type, and a slugified title.
	// Expected pattern: MP_SID_docType_slug.md
	expectedDraft := mp + "_" + sid + "_draft_my-novel.md"
	if draftFile != expectedDraft {
		t.Fatalf("draft filename %q does not match expected %q", draftFile, expectedDraft)
	}
	expectedNotes := mp + "_" + sid + "_notes.md"
	if notesFile != expectedNotes {
		t.Fatalf("notes filename %q does not match expected %q", notesFile, expectedNotes)
	}
}

// Adding a node bootstraps the control directory.
// Source: specs/US01-initialize-new-outline.txt:17
func Test_Adding_a_node_bootstraps_the_control_directory(t *testing.T) {
	// GIVEN a content directory with no control directory.
	// WHEN the author adds a node titled "First Entry".
	// THEN the control directory is created.
	// THEN the stable identifier reservation is stored in the control directory.
	// THEN the draft and notes files are created successfully.

	// GIVEN a content directory with no control directory.
	dir := t.TempDir()

	// Verify .linemark/ does NOT exist yet.
	controlDir := filepath.Join(dir, ".linemark")
	if _, err := os.Stat(controlDir); err == nil {
		t.Fatal("control directory .linemark/ should not exist before add")
	}

	// WHEN the author adds a node titled "First Entry".
	result := addNodeJSON(t, dir, "First Entry")
	sid := getNodeSID(t, result)

	// THEN the control directory is created.
	info, err := os.Stat(controlDir)
	if err != nil {
		t.Fatalf("control directory .linemark/ was not created: %v", err)
	}
	if !info.IsDir() {
		t.Fatal(".linemark exists but is not a directory")
	}

	// THEN the stable identifier reservation is stored in the control directory.
	// The control directory should contain a lock file (reservation mechanism).
	lockFile := filepath.Join(controlDir, "lock")
	if _, err := os.Stat(lockFile); err != nil {
		t.Fatalf("expected lock file in .linemark/: %v", err)
	}
	_ = sid // SID was assigned successfully, confirming reservation works.

	// THEN the draft and notes files are created successfully.
	mdFiles := listMDFiles(t, dir)
	if len(mdFiles) != 2 {
		t.Fatalf("expected 2 .md files, got %d: %v", len(mdFiles), mdFiles)
	}
	hasDraft := false
	hasNotes := false
	for _, f := range mdFiles {
		if strings.Contains(f, "_draft_") {
			hasDraft = true
		}
		if strings.Contains(f, "_notes") {
			hasNotes = true
		}
	}
	if !hasDraft {
		t.Fatal("draft file not created")
	}
	if !hasNotes {
		t.Fatal("notes file not created")
	}
}
