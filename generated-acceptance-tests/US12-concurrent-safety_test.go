// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US12-concurrent-safety.txt

package acceptance_test

import (
	"path/filepath"
	"strings"
	"testing"

	"github.com/gofrs/flock"
)

// Two mutating commands cannot run simultaneously.
// Source: specs/US12-concurrent-safety.txt:2
func Test_Two_mutating_commands_cannot_run_simultaneously(t *testing.T) {
	// GIVEN a mutating command is already running.
	dir := initProject(t)
	addNodeJSON(t, dir, "Existing")

	lockPath := filepath.Join(dir, ".linemark", "lock")
	fl := flock.New(lockPath)
	ok, err := fl.TryLock()
	if err != nil {
		t.Fatalf("failed to acquire lock: %v", err)
	}
	if !ok {
		t.Fatal("expected to acquire lock")
	}
	defer fl.Unlock()

	// WHEN a second mutating command is started.
	_, stderr, exitCode := runLmk(t, dir, "add", "Should Fail")

	// THEN the second command fails immediately with a clear error.
	if exitCode == 0 {
		t.Fatal("expected non-zero exit code when lock held")
	}
	if !strings.Contains(stderr, "already running") {
		t.Fatalf("expected lock error message, got: %s", stderr)
	}
}

// Read-only commands are not blocked by mutating commands.
// Source: specs/US12-concurrent-safety.txt:13
func Test_Read_only_commands_are_not_blocked_by_mutating_commands(t *testing.T) {
	// GIVEN a mutating command is running.
	dir := initProject(t)
	addNodeJSON(t, dir, "Existing")

	lockPath := filepath.Join(dir, ".linemark", "lock")
	fl := flock.New(lockPath)
	ok, err := fl.TryLock()
	if err != nil {
		t.Fatalf("failed to acquire lock: %v", err)
	}
	if !ok {
		t.Fatal("expected to acquire lock")
	}
	defer fl.Unlock()

	// WHEN a read-only command is started.
	_, _, exitCode := runLmk(t, dir, "list")

	// THEN the read-only command completes without waiting.
	if exitCode != 0 {
		t.Fatal("expected list to succeed while lock held")
	}
}

// The lock is released when a command fails.
// Source: specs/US12-concurrent-safety.txt:23
func Test_The_lock_is_released_when_a_command_fails(t *testing.T) {
	// GIVEN a mutating command encounters an error mid-operation.
	dir := initProject(t)
	addNodeJSON(t, dir, "Existing")

	// Run a failing mutating command (move non-existent node).
	_, _, exitCode := runLmk(t, dir, "move", "999", "--to", "100")
	if exitCode == 0 {
		t.Fatal("expected failing command")
	}

	// WHEN the command exits.
	// THEN the advisory lock is released.
	// THEN subsequent mutating commands can proceed.
	addNode(t, dir, "After Failure")
}
