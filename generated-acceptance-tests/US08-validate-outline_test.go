// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/US08-validate-outline.txt

package acceptance_test

import (
	"encoding/json"
	"testing"
)

// A healthy outline passes validation.
// Source: specs/US08-validate-outline.txt:2
func Test_A_healthy_outline_passes_validation(t *testing.T) {
	// GIVEN an outline with no structural problems.
	dir := initProject(t)
	addNodeJSON(t, dir, "Good Node")

	// WHEN the author validates the outline.
	_, _, exitCode := runLmk(t, dir, "check")

	// THEN the validation reports success.
	// THEN the exit status indicates success.
	if exitCode != 0 {
		t.Fatalf("expected exit 0 for healthy outline, got %d", exitCode)
	}
}

// Validation detects duplicate stable identifiers.
// Source: specs/US08-validate-outline.txt:13
func Test_Validation_detects_duplicate_stable_identifiers(t *testing.T) {
	// GIVEN an outline where two nodes share the same stable identifier.
	dir := initProject(t)
	dupSID := "FAKESID12345"
	writeFile(t, dir, "100_"+dupSID+"_draft_alpha.md", "---\ntitle: Alpha\n---\n")
	writeFile(t, dir, "100_"+dupSID+"_notes.md", "")
	writeFile(t, dir, "200_"+dupSID+"_draft_beta.md", "---\ntitle: Beta\n---\n")
	writeFile(t, dir, "200_"+dupSID+"_notes.md", "")

	// WHEN the author validates the outline.
	stdout, _, exitCode := runLmk(t, dir, "check", "--json")

	// THEN a finding reports the duplicate stable identifier.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v\noutput: %s", err, stdout)
	}
	findings, ok := result["findings"].([]interface{})
	if !ok || len(findings) == 0 {
		t.Fatal("expected findings for duplicate SIDs")
	}

	// THEN the exit status indicates findings detected.
	if exitCode == 0 {
		t.Fatal("expected non-zero exit code for duplicate SIDs")
	}
}

// Validation detects slug drift.
// Source: specs/US08-validate-outline.txt:24
func Test_Validation_detects_slug_drift(t *testing.T) {
	// GIVEN a node whose filename slug does not match its canonical title.
	dir := initProject(t)
	r := addNodeJSON(t, dir, "Correct Title")
	mp := getNodeMP(t, r)
	sid := getNodeSID(t, r)

	// Manually rename draft to wrong slug.
	oldFile := mp + "_" + sid + "_draft_correct-title.md"
	newFile := mp + "_" + sid + "_draft_wrong-slug.md"
	content := readFile(t, dir, oldFile)
	writeFile(t, dir, newFile, content)
	removeFile(t, dir, oldFile)

	// WHEN the author validates the outline.
	stdout, _, exitCode := runLmk(t, dir, "check", "--json")

	// THEN a finding reports the slug drift with the affected file.
	if exitCode == 0 {
		t.Fatal("expected non-zero exit code for slug drift")
	}
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v\noutput: %s", err, stdout)
	}
	findings, ok := result["findings"].([]interface{})
	if !ok || len(findings) == 0 {
		t.Fatal("expected findings for slug drift")
	}
	foundSlugDrift := false
	for _, f := range findings {
		fm := f.(map[string]interface{})
		if fm["type"] == "slug_drift" {
			foundSlugDrift = true
			break
		}
	}
	if !foundSlugDrift {
		t.Fatalf("expected slug_drift finding, got: %v", findings)
	}
}

// Validation detects missing required documents.
// Source: specs/US08-validate-outline.txt:34
func Test_Validation_detects_missing_required_documents(t *testing.T) {
	// GIVEN a node that is missing its notes document.
	dir := initProject(t)
	writeFile(t, dir, "100_FAKESID12345_draft_test.md", "---\ntitle: Test\n---\n")

	// WHEN the author validates the outline.
	stdout, _, exitCode := runLmk(t, dir, "check", "--json")

	// THEN a finding reports the missing notes document.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v\noutput: %s", err, stdout)
	}
	findings, ok := result["findings"].([]interface{})
	if !ok || len(findings) == 0 {
		t.Fatal("expected findings for missing notes")
	}
	if exitCode == 0 {
		t.Fatal("expected non-zero exit code for missing notes")
	}
}

// Validation detects malformed title metadata.
// Source: specs/US08-validate-outline.txt:44
func Test_Validation_detects_malformed_title_metadata(t *testing.T) {
	// GIVEN a draft document with unparseable title metadata.
	dir := initProject(t)
	addNodeJSON(t, dir, "Good Node")

	// Overwrite draft with malformed YAML.
	files := listMDFiles(t, dir)
	for _, f := range files {
		if len(f) > 10 && f[len(f)-8:] != "notes.md" {
			writeFile(t, dir, f, "---\n: : : broken yaml\n---\n")
			break
		}
	}

	// WHEN the author validates the outline.
	stdout, _, exitCode := runLmk(t, dir, "check", "--json")

	// THEN a finding reports the malformed metadata.
	if exitCode != 2 {
		t.Fatalf("expected exit code 2 for malformed frontmatter, got %d\nstdout: %s", exitCode, stdout)
	}
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v\noutput: %s", err, stdout)
	}
	findings, ok := result["findings"].([]interface{})
	if !ok || len(findings) == 0 {
		t.Fatal("expected findings for malformed frontmatter")
	}
	foundMalformed := false
	for _, f := range findings {
		fm := f.(map[string]interface{})
		if fm["type"] == "malformed_frontmatter" {
			foundMalformed = true
			break
		}
	}
	if !foundMalformed {
		t.Fatalf("expected malformed_frontmatter finding, got: %v", findings)
	}
}

// Validation never modifies files.
// Source: specs/US08-validate-outline.txt:54
func Test_Validation_never_modifies_files(t *testing.T) {
	// GIVEN an outline with several findings.
	dir := initProject(t)
	writeFile(t, dir, "100_FAKESID12345_draft_test.md", "---\ntitle: Test\n---\n")
	// Missing notes file creates a finding.

	snap := snapshotFiles(t, dir)

	// WHEN the author validates the outline.
	runLmk(t, dir, "check")

	// THEN no files are created, renamed, or deleted.
	assertSnapshotUnchanged(t, dir, snap)
}

// Validation supports structured output.
// Source: specs/US08-validate-outline.txt:64
func Test_Validation_supports_structured_output(t *testing.T) {
	// GIVEN an outline with findings.
	dir := initProject(t)
	writeFile(t, dir, "100_FAKESID12345_draft_test.md", "---\ntitle: Test\n---\n")

	// WHEN the author validates requesting structured output.
	stdout, _, _ := runLmk(t, dir, "check", "--json")

	// THEN each finding includes its category, severity, message, and affected file path.
	var result map[string]interface{}
	if err := json.Unmarshal([]byte(stdout), &result); err != nil {
		t.Fatalf("invalid JSON: %v\noutput: %s", err, stdout)
	}
	findings, ok := result["findings"].([]interface{})
	if !ok || len(findings) == 0 {
		t.Fatal("expected findings in structured output")
	}
	finding := findings[0].(map[string]interface{})
	for _, field := range []string{"type", "severity", "message"} {
		if _, ok := finding[field]; !ok {
			t.Fatalf("missing field %q in finding", field)
		}
	}
}
