package acceptance

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// sanitizeFuncName converts a description into a valid Go test function name suffix.
func sanitizeFuncName(desc string) string {
	// Replace non-alphanumeric characters with underscores
	re := regexp.MustCompile(`[^a-zA-Z0-9]+`)
	name := re.ReplaceAllString(desc, "_")
	// Trim trailing underscores
	name = strings.TrimRight(name, "_")
	return name
}

// GenerateTests transforms a Feature into executable Go test source code.
// Each scenario becomes a test function with t.Fatal stubs that fail by design
// until step bindings are implemented.
func GenerateTests(feature *Feature) (string, error) {
	var b strings.Builder

	fmt.Fprintf(&b, "// Code generated by acceptance-pipeline. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "// Source: %s\n\n", feature.SourceFile)
	fmt.Fprintf(&b, "package acceptance_test\n\n")

	if len(feature.Scenarios) > 0 {
		fmt.Fprintf(&b, "import (\n")
		fmt.Fprintf(&b, "\t\"testing\"\n")
		fmt.Fprintf(&b, ")\n")
	}

	for _, scenario := range feature.Scenarios {
		funcName := "Test_" + sanitizeFuncName(scenario.Description)
		fmt.Fprintf(&b, "\n// %s\n", scenario.Description)
		fmt.Fprintf(&b, "// Source: %s:%d\n", feature.SourceFile, scenario.Line)
		fmt.Fprintf(&b, "func %s(t *testing.T) {\n", funcName)

		for _, step := range scenario.Steps {
			fmt.Fprintf(&b, "\t// %s %s\n", step.Keyword, step.Text)
		}
		fmt.Fprintf(&b, "\n")
		fmt.Fprintf(&b, "\tt.Fatal(\"acceptance test not yet bound\")\n")
		fmt.Fprintf(&b, "}\n")
	}

	return b.String(), nil
}

// WriteTestFileImpl writes generated test code to disk, creating directories as needed.
// This is an Impl function exempt from coverage requirements.
func WriteTestFileImpl(path string, content string) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}
	return os.WriteFile(path, []byte(content), 0o644)
}
